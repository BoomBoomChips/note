---
typora-root-url: images
---

# 伊始

冲冲冲

### 警告

自动生成getter和setter的方法时候，一定要检查

有时候会生成不完全

### 一些脑残问题，不要在问了

#### 箭头函数

```javascriptj
x => x * x
```

上面的箭头函数相当于：

```javascript
function (x) {
    return x * x;
}
```

### Mapper通用端口

#### insert和insertSelective的区别：

![](/1.png)



![](/2.jpg)

区别就是insert会在参数不够的时候，自动帮你赋值null

然后insertSelective在，比如说没有images的时候，他是不会帮你赋值null的，相当

INSERT INTO tb_brand(id,name,letter) values values (xxx,xxx,xxx)



**虽说效果是一样的，但是这样的话效率是高很多的**



#### mapper中自定义方法

![](/3_Mapper中自定义方法.png)

Insert就写insert，select就select



#### ⭐#号$的区别

**“#” 会生成 ？ 是占位符, $ 会直接拼接 sql 字符串**

```mysql
insert into 表 values(#{id} , #{username}, #{password })
insert into 表 values(?,?,?)

insert into 表 values(${id} , '${username}', '${password }')
insert into 表 values(1,'zhangsan','123')	
```

**#更安全，而 $ 有sql注入风险**

```mysql
select * from ${tablename} order by ${column}

select * from #{tablename} order by #{column}
select * from ? order by ?
```

**$ 可以拼接sql中的任意部分, 而 # 只能给值进行占位，不能对表名，列名进行占位**

**$ 内可以进行一些简单运算, # 内不能做运算**

```mysql
map
	page = 1
	pageSize = 5
	
select * from user limit ${(page-1)* pageSize}, ${pageSize}
```

**${} 在映射文件（mapper）中使用，还可以在 核心配置文件中使用. #{} 只能在映射文件中使用**

实战出错,在mybatis持久层的xml文件中,不小心将#错写程$导致程序报错,从报错可以看出," ${变量名}"是从类中属性取值,从而使得我传入的基本类型和字符串类型无法被找到.说该类中没有我写的变量名的属性.从而报错500;

## ⭐解决400

### 原因分析

我们填写表单并提交，发现报错了。查看控制台的请求详情：

![1530696121642](/1530696121642.png)



发现请求的数据格式是JSON格式。

> 原因分析：

axios处理请求体的原则会根据请求数据的格式来定：

- 如果请求体是对象：会转为json发送

- 如果请求体是String：会作为普通表单请求发送，但需要我们自己保证String的格式是键值对。

  如：name=jack&age=12



### QS工具

QS是一个第三方库，我们可以用`npm install qs --save`来安装。不过我们在项目中已经集成了，大家无需安装：

![1530696509189](/1530696509189.png)

这个工具的名字：QS，即Query String，请求参数字符串。

什么是请求参数字符串？例如： name=jack&age=21

QS工具可以便捷的实现 JS的Object与QueryString的转换。



在我们的项目中，将QS注入到了Vue的原型对象中，我们可以通过`this.$qs`来获取这个工具：

![1539821449329](/1539821449329.png)

我们将`this.$qs`对象打印到控制台：

```js
created(){
    console.log(this.$qs);
}
```

发现其中有3个方法：

![1532850873556](/1532850873556.png)

这里我们要使用的方法是stringify，它可以把Object转为QueryString。



测试一下，使用浏览器工具，把qs对象保存为一个临时变量temp1，然后调用stringify方法：

![1526182230872](/qs-2.gif)

成功将person对象变成了 name=zhangsan&age=30的字符串了



### 解决问题，按原对象发送

修改页面，对参数处理后发送：

![1545223244002](/1545223244002.png)

然后再次发起请求，发现请求成功：

![1530698685973](/1530698685973.png)



## 1.4.新增完成后关闭窗口

我们发现有一个问题：新增不管成功还是失败，窗口都一致在这里，不会关闭。

这样很不友好，我们希望如果新增失败，窗口保持；但是新增成功，窗口关闭才对。



因此，我们需要**在新增的ajax请求完成以后，关闭窗口**

但问题在于，控制窗口是否显示的标记在父组件：MyBrand.vue中。子组件如何才能操作父组件的属性？或者告诉父组件该关闭窗口了？



之前我们讲过一个父子组件的通信，有印象吗？

- 第一步：在父组件中定义一个函数，用来关闭窗口，不过之前已经定义过了。父组件在使用子组件时，绑定事件，关联到这个函数：Brand.vue

```html
<!--对话框的内容，表单-->
<v-card-text class="px-5" style="height:400px">
    <brand-form @close="closeWindow" :oldBrand="oldBrand" :isEdit="isEdit"/>
</v-card-text>
```

- 第二步，子组件通过`this.$emit`调用父组件的函数：BrandForm.vue

![1545223341933](/1545223341933.png)



测试一下，保存成功：

![1530713222558](/1530713222558.png)



我们优化一下，关闭的同时重新加载数据：

```js
closeWindow(){
    // 关闭窗口
    this.show = false;
    // 重新加载数据
    this.getDataFromServer();
}
```

